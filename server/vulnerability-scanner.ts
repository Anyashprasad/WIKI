import axios from 'axios';
import * as cheerio from 'cheerio';
import { JSDOM } from 'jsdom';
import { URL } from 'url';
import { Vulnerability } from '../shared';
import { SmartWebCrawler, CrawledPage } from './web-crawler';
import { WorkerPool } from './worker-pool';
import { WebSocketServer } from './websocket-server';
import { storage } from './storage';


export interface ScanResult {
  vulnerabilities: Vulnerability[];
  scanTime: number;
  formsFound: number;
  endpointsTested: number;
  pagesScanned: number;
  crawlStats?: object;
}

/**
 * Core vulnerability scanner class.
 * Manages the web crawling and vulnerability detection process using a pool of worker threads.
 */
export class VulnerabilityScanner {
  private url: string; // Changed from url
  private vulnerabilities: Vulnerability[] = [];
  private scanStartTime: number;
  private formsFound: number = 0;
  private endpointsTested: number = 0;
  private pagesScanned: number = 0;
  private crawler: SmartWebCrawler;
  private crawledPages: CrawledPage[] = [];
  private workerPool: WorkerPool;
  private scanId: string; // Changed from scanId?
  private wsServer?: WebSocketServer;

  /**
   * Creates a new instance of the VulnerabilityScanner.
   * 
   * @param url - The target URL to scan.
   * @param scanId - The unique ID of the scan session.
   * @param wsServer - Optional WebSocket server for real-time progress updates.
   */
  constructor(url: string, scanId: string, wsServer?: WebSocketServer) {
    this.url = url;
    this.scanId = scanId;
    this.wsServer = wsServer;
    this.scanStartTime = Date.now();

    // Extract domain for more focused crawling
    const urlObj = new URL(url);
    const baseDomain = urlObj.hostname;

    this.crawler = new SmartWebCrawler({
      maxDepth: 2,
      maxPages: 15,
      sameDomainOnly: false, // Allow external crawling for testing
      includePatterns: [
        'dashboard', 'admin', 'settings', 'profile', 'account',
        'home', 'index', 'main', 'login', 'register',
        'users', 'products', 'services', 'pages',
        'api', 'v1', 'v2', 'endpoints', 'phone', 'agents',
        'vulnweb.com', 'testphp', 'testhtml5', 'testasp', 'testaspnet',
        'guestbook', 'cart', 'categories', 'artists', 'disclaimer'
      ]
    });

    // Initialize worker pool with 5 workers for concurrent processing
    this.workerPool = new WorkerPool({
      workerCount: 5,
      rateLimitDelay: 2000, // 2 seconds between requests
      maxConcurrentRequests: 10
    });
  }

  async scan(): Promise<ScanResult> {
    try {
      console.log(`Starting comprehensive vulnerability scan for: ${this.url}`);

      // First, crawl the website to discover all relevant pages
      console.log('üï∑Ô∏è  Starting web crawling...');
      this.crawledPages = await this.crawler.crawl(this.url);
      // Sort pages to ensure deterministic order across runs
      this.crawledPages = this.crawler.getCrawledPages().sort((a, b) => a.url.localeCompare(b.url));
      console.log(`üï∑Ô∏è  Crawling completed. ${this.crawledPages.length} pages ready for scanning.`);

      // Update crawling progress with total pages found
      if (this.wsServer && this.scanId) {
        this.wsServer.updateCrawlingProgress(this.scanId, this.crawledPages.length);
      }

      // Use worker pool for concurrent page scanning
      console.log('üöÄ Starting concurrent page scanning with worker pool...');

      // Setup progress tracking
      let completedPages = 0;
      let currentVulns = 0;
      let currentForms = 0;
      let currentEndpoints = 0;

      const progressListener = (result: any) => {
        completedPages++;
        if (result.success && result.data) {
          currentVulns += result.data.vulnerabilities?.length || 0;
          currentForms += result.data.formsFound || 0;
          currentEndpoints += result.data.endpointsTested || 0;
        }

        if (this.wsServer && this.scanId) {
          this.wsServer.updateScanningProgress(
            this.scanId,
            completedPages,
            currentVulns,
            currentForms,
            currentEndpoints,
            this.vulnerabilities // Pass current vulnerabilities
          );
        }
      };

      this.workerPool.on('result', progressListener);

      const results = await this.workerPool.scanPages(this.scanId!, this.crawledPages);

      // Remove listener to avoid memory leaks
      this.workerPool.off('result', progressListener);

      // Aggregate results from all workers
      for (const result of results) {
        if (result.success && result.data) {
          // Combine vulnerabilities from all workers
          if (result.data.vulnerabilities && Array.isArray(result.data.vulnerabilities)) {
            this.vulnerabilities.push(...result.data.vulnerabilities);
          }

          // Update statistics
          this.formsFound += result.data.formsFound || 0;
          this.endpointsTested += result.data.endpointsTested || 0;
          this.pagesScanned++;
        }
      }

      // Remove duplicate vulnerabilities
      this.vulnerabilities = this.vulnerabilities.filter((vuln, index, self) =>
        index === self.findIndex(v => v.id === vuln.id)
      );

      const scanTime = Date.now() - this.scanStartTime;
      const crawlStats = this.crawler.getCrawlStats();

      console.log(`‚úÖ Comprehensive scan completed!`);
      console.log(`üìä Found ${this.vulnerabilities.length} vulnerabilities across ${this.pagesScanned} pages`);

      // Shutdown worker pool
      await this.workerPool.shutdown();
      await storage.updateScan(this.scanId!, {
        vulnerabilities: this.vulnerabilities,
        pagesScanned: this.pagesScanned,
        formsFound: this.formsFound,
        endpointsTested: this.endpointsTested,
        status: 'completed'
      });


      return {
        vulnerabilities: this.vulnerabilities,
        scanTime,
        formsFound: this.formsFound,
        endpointsTested: this.endpointsTested,
        pagesScanned: this.pagesScanned,
        crawlStats
      };
    } catch (error: any) {
      console.error('Scan error:', error);
      // Ensure worker pool is shutdown even on error
      if (this.workerPool) {
        await this.workerPool.shutdown();
      }
      throw new Error(`Failed to scan ${this.url}: ${error.message}`);
    }
  }

  private async fetchPage(url: string) {
    try {
      return await axios.get(url, {
        timeout: 10000,
        headers: {
          'User-Agent': 'SecureScan-Vulnerability-Scanner/1.0'
        },
        validateStatus: (status) => status < 500
      });
    } catch (error: any) {
      throw new Error(`Failed to fetch ${url}: ${error.message}`);
    }
  }

  private async scanPage(page: CrawledPage): Promise<void> {
    try {
      const response = await this.fetchPage(page.url);
      const $ = cheerio.load(response.data);
      const dom = new JSDOM(response.data);

      // Scan this specific page for vulnerabilities
      await this.scanForXSS($, dom, page.url);
      await this.scanForSQLInjection($, page.url);
      await this.scanForCSRF($, dom, page.url);
      await this.scanForInformationDisclosure(response, page.url);

      // Also scan forms discovered during crawling
      for (const form of page.forms) {
        await this.scanFormForVulnerabilities(form, page.url);
      }

    } catch (error: any) {
      console.error(`‚ùå Error scanning page ${page.url}:`, error.message);
    }
  }

  private async scanFormForVulnerabilities(form: any, pageUrl: string): Promise<void> {
    try {
      // Test this form for XSS and SQL injection
      for (const input of form.inputs) {
        if (input.name) {
          await this.testXSSPayload(form.action, form.method, input.name, pageUrl);
          await this.testSQLInjection(form.action, form.method, input.name, pageUrl);
        }
      }
    } catch (error: any) {
      console.error(`‚ùå Error scanning form on ${pageUrl}:`, error.message);
    }
  }

  private async scanForXSS($: cheerio.CheerioAPI, dom: JSDOM, pageUrl: string): Promise<void> {
    console.log(`Scanning for XSS vulnerabilities on: ${pageUrl}`);

    // Test forms for XSS
    const forms = $('form');
    this.formsFound += forms.length;

    for (let i = 0; i < forms.length; i++) {
      const form = forms.eq(i);
      const action = form.attr('action') || pageUrl;
      const method = (form.attr('method') || 'GET').toUpperCase();
      const inputs = form.find('input[type="text"], input[type="search"], textarea');

      for (let j = 0; j < inputs.length; j++) {
        const input = inputs.eq(j);
        const inputName = input.attr('name');

        if (inputName) {
          await this.testXSSPayload(action, method, inputName, pageUrl);
        }
      }
    }

    // Test URL parameters for XSS
    const url = new URL(pageUrl);
    for (const [param, value] of url.searchParams) {
      await this.testURLXSS(pageUrl, param);
    }

    // Check for existing XSS vulnerabilities in the page
    this.checkForExistingXSS($, dom, pageUrl);
  }

  private async testXSSPayload(action: string, method: string, inputName: string, pageUrl: string): Promise<void> {
    const xssPayloads = [
      '<script>alert("XSS")</script>',
      '"><script>alert("XSS")</script>',
      '<img src=x onerror=alert("XSS")>',
      'javascript:alert("XSS")',
      '<svg onload=alert("XSS")>',
      '"><img src=x onerror=alert("XSS")>',
      '<iframe src="javascript:alert(\'XSS\')"></iframe>'
    ];

    for (const payload of xssPayloads) {
      try {
        const url = action.startsWith('http') ? action : new URL(action, pageUrl).href;
        const params = new URLSearchParams();
        params.append(inputName, payload);

        this.endpointsTested++;

        let response;
        if (method === 'POST') {
          response = await axios.post(url, params.toString(), {
            headers: { 'Content-Type': 'application/x-www-form-urlencoded' },
            timeout: 5000
          });
        } else {
          response = await axios.get(`${url}?${params.toString()}`, { timeout: 5000 });
        }

        // Check if payload is reflected in response
        if (this.containsPayload(response.data, payload)) {
          this.addVulnerability({
            id: `xss-${Date.now()}`,
            name: 'Cross-Site Scripting (XSS)',
            severity: 'High',
            description: `Reflected XSS vulnerability found in form input "${inputName}" on page ${pageUrl}. User input is not properly sanitized before being reflected in the response.`,
            location: `${method} ${url}`,
            impact: 'Malicious scripts could be executed in users\' browsers, potentially stealing session tokens or performing actions on behalf of users.',
            category: 'XSS'
          });
          break; // Don't test more payloads for this input
        }
      } catch (error: any) {
        // Continue testing other payloads
      }
    }
  }

  private async testURLXSS(url: string, param: string): Promise<void> {
    const xssPayload = '<script>alert("XSS")</script>';
    const testUrl = new URL(url);
    testUrl.searchParams.set(param, xssPayload);

    try {
      this.endpointsTested++;
      const response = await axios.get(testUrl.toString(), { timeout: 5000 });

      if (this.containsPayload(response.data, xssPayload)) {
        this.addVulnerability({
          id: `url-xss-${Date.now()}`,
          name: 'Cross-Site Scripting (XSS)',
          severity: 'High',
          description: `Reflected XSS vulnerability found in URL parameter "${param}". User input is not properly sanitized before being reflected in the response.`,
          location: `GET ${testUrl.pathname}`,
          impact: 'Malicious scripts could be executed in users\' browsers, potentially stealing session tokens or performing actions on behalf of users.',
          category: 'XSS'
        });
      }
    } catch (error: any) {
      // Continue testing
    }
  }

  private checkForExistingXSS($: cheerio.CheerioAPI, dom: JSDOM, pageUrl: string): void {
    // Check for dangerous JavaScript patterns
    const scripts = $('script');
    for (let i = 0; i < scripts.length; i++) {
      const script = scripts.eq(i).html() || '';

      // Check for dangerous patterns
      if (script.includes('innerHTML') || script.includes('document.write')) {
        this.addVulnerability({
          id: `dom-xss-${Date.now()}`,
          name: 'DOM-Based Cross-Site Scripting (XSS)',
          severity: 'High',
          description: `Potentially dangerous DOM manipulation detected on page ${pageUrl}. The page uses innerHTML or document.write which could lead to DOM-based XSS if user input is involved.`,
          location: 'Inline JavaScript',
          impact: 'Malicious scripts could be executed in users\' browsers through DOM manipulation, potentially stealing session tokens or performing actions on behalf of users.',
          category: 'XSS'
        });
      }
    }
  }

  private async scanForSQLInjection($: cheerio.CheerioAPI, pageUrl: string): Promise<void> {
    console.log(`Scanning for SQL Injection vulnerabilities on: ${pageUrl}`);

    const forms = $('form');

    for (let i = 0; i < forms.length; i++) {
      const form = forms.eq(i);
      const action = form.attr('action') || pageUrl;
      const method = (form.attr('method') || 'GET').toUpperCase();
      const inputs = form.find('input[type="text"], input[type="password"], input[type="email"], textarea');

      for (let j = 0; j < inputs.length; j++) {
        const input = inputs.eq(j);
        const inputName = input.attr('name');

        if (inputName) {
          await this.testSQLInjection(action, method, inputName, pageUrl);
        }
      }
    }
  }

  private async testSQLInjection(action: string, method: string, inputName: string, pageUrl: string): Promise<void> {
    const sqlPayloads = [
      "' OR '1'='1",
      "' OR 1=1--",
      "'; DROP TABLE users;--",
      "' UNION SELECT null, null, null--",
      "admin'--",
      "admin' #",
      "admin'/*",
      "' or 1=1#",
      "' or 1=1--",
      "' or 1=1/*",
      "') or '1'='1--",
      "') or ('1'='1--"
    ];

    for (const payload of sqlPayloads) {
      try {
        const url = action.startsWith('http') ? action : new URL(action, pageUrl).href;
        const params = new URLSearchParams();
        params.append(inputName, payload);

        this.endpointsTested++;

        let response;
        if (method === 'POST') {
          response = await axios.post(url, params.toString(), {
            headers: { 'Content-Type': 'application/x-www-form-urlencoded' },
            timeout: 5000
          });
        } else {
          response = await axios.get(`${url}?${params.toString()}`, { timeout: 5000 });
        }

        // Check for SQL error messages
        if (this.containsSQLError(response.data)) {
          this.addVulnerability({
            id: `sqli-${Date.now()}`,
            name: 'SQL Injection',
            severity: 'Critical',
            description: `SQL Injection vulnerability found in form input "${inputName}" on page ${pageUrl}. The application appears to be vulnerable to SQL injection attacks.`,
            location: `${method} ${url}`,
            impact: 'Attackers could potentially access, modify, or delete database contents, including sensitive user information.',
            category: 'SQL Injection'
          });
          break; // Don't test more payloads for this input
        }
      } catch (error: any) {
        // Check if error is due to SQL injection (database error)
        if (error.response && this.containsSQLError(error.response.data)) {
          this.addVulnerability({
            id: `sqli-${Date.now()}`,
            name: 'SQL Injection',
            severity: 'Critical',
            description: `SQL Injection vulnerability found in form input "${inputName}" on page ${pageUrl}. SQL error detected in response.`,
            location: `${method} ${action}`,
            impact: 'Attackers could potentially access, modify, or delete database contents, including sensitive user information.',
            category: 'SQL Injection'
          });
          break;
        }
      }
    }
  }

  private async scanForCSRF($: cheerio.CheerioAPI, dom: JSDOM, pageUrl: string): Promise<void> {
    console.log(`Scanning for CSRF vulnerabilities on: ${pageUrl}`);

    const forms = $('form');

    for (let i = 0; i < forms.length; i++) {
      const form = forms.eq(i);
      const action = form.attr('action') || pageUrl;
      const method = (form.attr('method') || 'GET').toUpperCase();

      // Check for CSRF tokens
      const csrfTokens = form.find('input[type="hidden"][name*="csrf"], input[type="hidden"][name*="token"]');
      const hasCSRFToken = csrfTokens.length > 0;

      // Check if form submits sensitive data
      const sensitiveInputs = form.find('input[type="password"], input[name*="password"], input[name*="email"]');
      const hasSensitiveData = sensitiveInputs.length > 0;

      if (method === 'POST' && hasSensitiveData && !hasCSRFToken) {
        this.addVulnerability({
          id: `csrf-${Date.now()}`,
          name: 'Cross-Site Request Forgery (CSRF)',
          severity: 'Medium',
          description: `CSRF protection missing on sensitive form on page ${pageUrl}. State-changing operations can be performed without proper token validation.`,
          location: `POST ${action}`,
          impact: 'Attackers could trick users into performing unintended actions like changing account settings or making transactions.',
          category: 'CSRF'
        });
      }
    }
  }

  private async scanForInformationDisclosure(response: any, pageUrl: string): Promise<void> {
    console.log(`Scanning for information disclosure on: ${pageUrl}`);

    // Check for server headers
    const serverHeader = response.headers['server'];
    if (serverHeader && serverHeader.includes('Apache')) {
      this.addVulnerability({
        id: `info-${Date.now()}`,
        name: 'Information Disclosure - Server Version',
        severity: 'Low',
        description: `Server version is disclosed in HTTP headers on page ${pageUrl}. This information could help attackers identify potential vulnerabilities.`,
        location: 'HTTP Response Headers',
        impact: 'Attackers could use this information to identify specific vulnerabilities for the disclosed server version.',
        category: 'Information Disclosure'
      });
    }

    // Check for error messages
    const errorPatterns = [
      /mysql_fetch_array/,
      /ORA-[0-9]{5}/,
      /Microsoft OLE DB Provider/,
      /PostgreSQL query failed/,
      /Warning:.*mysql_.*/
    ];

    for (const pattern of errorPatterns) {
      if (pattern.test(response.data)) {
        this.addVulnerability({
          id: `error-${Date.now()}`,
          name: 'Information Disclosure - Error Messages',
          severity: 'Medium',
          description: `Detailed error messages are exposed on page ${pageUrl}, potentially revealing system information.`,
          location: 'Application Response',
          impact: 'Attackers could use error messages to gather information about the underlying system and database.',
          category: 'Information Disclosure'
        });
        break;
      }
    }
  }

  private containsPayload(responseData: string, payload: string): boolean {
    return responseData.toLowerCase().includes(payload.toLowerCase());
  }

  private containsSQLError(responseData: string): boolean {
    const sqlErrors = [
      'mysql_fetch_array',
      'ORA-',
      'Microsoft OLE DB Provider',
      'PostgreSQL query failed',
      'Warning: mysql_',
      'SQL syntax',
      'mysql_error',
      'valid MySQL result',
      'MySqlClient'
    ];

    const lowerData = responseData.toLowerCase();
    return sqlErrors.some(error => lowerData.includes(error.toLowerCase()));
  }

  private addVulnerability(vulnerability: Vulnerability): void {
    // Check if this vulnerability already exists
    const exists = this.vulnerabilities.some(v =>
      v.name === vulnerability.name &&
      v.location === vulnerability.location
    );

    if (!exists) {
      this.vulnerabilities.push(vulnerability);
    }
  }
}
